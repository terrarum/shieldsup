last = 0;
var generated = 0;
var generatedCounter = 0;
var generatedPerSecond = 0;

// Update all game values.
window.game.update = function(delta) {

    // Generate power.
    generated = generatePower(delta);
    // Store power.
    storePower(delta, generated);

    generatedCounter += generated;
    now = game.fn.timestamp();

    // Every second:
    if (now - last >= 1000) {
        last = game.fn.timestamp();

        generatedPerSecond = generatedCounter;
        generatedCounter = 0;
    }
};

// Render the game.
window.game.render = function(delta) {
    $('.js-generated-count').html(generatedPerSecond.toFixed(2))

    $('.js-batteries').empty();
    _.forEach(game.sim.components.batteries, function(battery, i) {
        $('.js-batteries').append(progressbar(battery.currentCapacity / battery.maxCapacity * 100, battery.currentCapacity.toFixed(0)))
    });
};

// Calculate power generated by all active generators.
var generatePower = function(delta) {
    generated = 0;
    _.forEach(game.sim.components.generators, function(generator, i) {
        generated += generator.generate(delta);
    });
    return generated;
};

// Returns a progressbar.
var progressbar = function(percentage, total) {
    return '<div class="progress">' +
    '<div class="progress-bar" role="progressbar" style="width: '+ percentage + '%;">' +
    '<span class="sr-only">'+ percentage + '%</span>' +
    '</div></div>' +
    '<div style="text-align: center">' + total + ' MW</div>';
}

// Store power in the batteries.
var storePower = function(delta, generated) {
    _.forEach(game.sim.components.batteries, function(battery, i) {
        battery.storePower(generated / game.sim.components.batteries.length);
    });
};